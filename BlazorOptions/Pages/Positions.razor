@page "/positions"
@page "/positions/{PositionId:guid?}"
@implements IAsyncDisposable
@inject PositionBuilderViewModel ViewModel
@inject IDialogService DialogService
@inject INavigationService NavigationService
@inject NavigationManager NavigationManager
@inject ThemeService ThemeService
@inject IJSRuntime JS
@using System.Linq
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.JSInterop
@using BlazorOptions.Shared
@using BlazorOptions.ViewModels
@using BlazorChart.Models

<PageTitle>Positions</PageTitle>

@if (_routeErrorMessage is not null)
{
    <MudStack Spacing="2" Class="route-error-panel">
        <MudAlert Severity="Severity.Error" Variant="Variant.Filled">
            @_routeErrorMessage
        </MudAlert>
        <MudStack Row="true" Spacing="1">
            <MudButton Color="Color.Primary" Variant="Variant.Filled" OnClick="NavigateToFirstPosition">Open first available position</MudButton>
            <MudButton Color="Color.Primary" Variant="Variant.Outlined" OnClick="CreatePosition">Create new position</MudButton>
        </MudStack>
    </MudStack>
}
else
{
    <MudStack>
        <MudCard>
        <MudCardContent>
            <MudStack Spacing="2">
                <MudStack Spacing="1">
                    <MudText Typo="Typo.h4">Positions</MudText>
                    <MudStack Row="true" AlignItems="AlignItems.Center" Justify="Justify.SpaceBetween" Spacing="2">
                        <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2" Class="position-select-row">
                            <MudSelect T="Guid?" Class="position-select"
                                       Value="@ViewModel.SelectedPosition?.Position?.Id"
                                       ValueChanged="HandlePositionChange"
                                       Variant="Variant.Text"
                                       Adornment="Adornment.Start"
                                       AdornmentIcon="@Icons.Material.Filled.ListAlt">
                                @foreach (var pos in ViewModel.Positions)
                                {
                                    <MudSelectItem T="Guid?" Value="@pos.Id" @key="pos.Id">@FormatPositionName(pos)</MudSelectItem>
                                }
                            </MudSelect>
                            <MudIconButton Icon="@Icons.Material.Filled.AddCircle" Color="Color.Primary" OnClick="CreatePosition" />
                        </MudStack>
                        <MudMenu Icon="@Icons.Material.Filled.MoreVert"
                                 Disabled="@(!HasActivePosition)"
                                 Dense="true"
                                 AnchorOrigin="Origin.BottomCenter"
                                 TransformOrigin="Origin.TopCenter"
                                 ListClass="tab-actions-menu">
                            <MudMenuItem Disabled="@(!HasActivePosition)" OnClick="OpenRenameDialogAsync">
                                <MudIcon Icon="@Icons.Material.Filled.Edit" Class="mr-2" /> Edit position
                            </MudMenuItem>
                            <MudMenuItem Disabled="@(!HasActivePosition)" OnClick="async () => await ConfirmAndRemovePositionAsync(ViewModel.SelectedPosition)">
                                <MudIcon Icon="@Icons.Material.Filled.Delete" Class="mr-2" /> Delete position
                            </MudMenuItem>
                        </MudMenu>
                    </MudStack>
                </MudStack>
            </MudStack>
        </MudCardContent>
        <MudCardContent Class="position-content">
            <MudGrid Spacing="2" Class="position-grid">
                <MudItem xs="12" md="8">
                    <MudPaper Class="chart-surface" Elevation="0">
                        <MudStack Spacing="2">
                            <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="1" Class="position-summary-row">
                                <MudChip T="string" Variant="Variant.Filled" Size="Size.Small" Color="@ResolvePnlColor(ResolveTotalCombinedPnl())">
                                    Total P/L: @FormatPrice(ResolveTotalCombinedPnl())
                                </MudChip>
                            </MudStack>
                           
                            <PayoffChart Strategies="@ViewModel.ChartStrategies"
                                         SelectedPrice="@ViewModel.ChartSelectedPrice"
                                         SelectedPriceChanged="HandleChartPriceSelected"
                                         Markers="@ViewModel.ChartMarkers"
                                         ShowCandles="false"
                                         ShowLegends="true"
                                         IsDarkTheme="@ThemeService.IsDarkMode"
                                         Range="@ViewModel.ChartRange"
                                         RangeChanged="HandleChartRangeChanged" />

                                <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2" Class="chart-controls-row">
                                    <MudText Typo="Typo.subtitle2">Valuation date</MudText>
                                    <MudDatePicker Date="@ViewModel.ValuationDate"
                                                   DateChanged="OnValuationDateChanged"
                                                   DateFormat="yyyy-MM-dd"
                                                   Clearable="true"
                                                   MinDate="@DateTime.UtcNow.Date"
                                                   MaxDate="@ViewModel.MaxExpiryDate"
                                                   Class="valuation-date-picker" />
                                    <MudText Typo="Typo.caption">@ViewModel.DaysToExpiryLabel</MudText>
                                    <MudSpacer />
                                    <MudSwitch T="bool"
                                               Color="Color.Primary"
                                               Value="@ViewModel.IsLive"
                                               ValueChanged="OnLivePriceChanged"
                                               Label="Live" />
                                    <MudText Typo="Typo.caption" Class="ml-2">Index Price</MudText>
                                    <MudNumericField T="decimal?"
                                                     Value="@ViewModel.SelectedPrice"
                                                     ValueChanged="OnTemporaryPriceChanged"
                                                     Immediate="true"
                                                     Variant="Variant.Outlined"
                                                     Margin="Margin.Dense"
                                                     Adornment="Adornment.End"
                                                     AdornmentText="USDT"
                                                     Class="temp-price-field" />
                                </MudStack>
                                <MudSlider T="int"
                                           Min="0"
                                           Max="@ViewModel.MaxExpiryDays"
                                           Step="1"
                                           Value="@ViewModel.SelectedDayOffset"
                                           ValueChanged="OnValuationDateOffsetChanged"
                                           TickMarks="true"
                                           Class="valuation-date-slider" />
                        </MudStack>
                    </MudPaper>
                </MudItem>
                @if (ViewModel.SelectedPosition != null)
                {
                    <MudItem xs="12" md="4">
                        <MudPaper Class="notes-panel" Elevation="0">
                            <MudText Typo="Typo.subtitle2">Notes</MudText>
                            <MudTextField T="string"
                                          @bind-Value="@ViewModel.SelectedPosition.Position.Notes"

                                          Variant="Variant.Outlined"
                                          Margin="Margin.Dense"
                                          Lines="16"
                                          FullWidth="true"
                                          Placeholder="Write notes about this position..."/>
                        </MudPaper>
                    </MudItem>
                }
            </MudGrid>
        </MudCardContent>
    </MudCard>

        @if (ViewModel.SelectedPosition is not null)
        {
            <PositionPanel ViewModel="@ViewModel.SelectedPosition" />
        }
    </MudStack>
}

<style>
    .position-swipe-area {
        display: block;
        flex: 1;
        min-width: 0;
    }

    .position-tabs .mud-tabs-toolbar {
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
    }

    .position-tabs .mud-tabs-toolbar-content {
        flex-wrap: nowrap;
    }

    .position-tabs .d-none {
        display: none !important;
    }

    .tab-name-field {
        min-width: 140px;
    }

    .tab-name-label {
        display: inline-block;
        max-width: 180px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        padding: 6px 12px;
    }

    .tab-actions-menu {
        min-width: 180px;
    }

    .temp-price-field {
        max-width: 180px;
    }

    .valuation-date-slider {
        padding: 0 14px 16px;
    }

    .valuation-date-picker {
        min-width: 140px;
        max-width: 170px;
        width: 170px;
    }

    .quick-leg-input {
        width: 220px;
    }
    .position-select-row {
        flex-wrap: wrap;
        gap: 8px;
        width: 100%;
    }
    .position-select-row .mud-select-root {
        flex: 1;
        min-width: 0;
    }
    .position-select .mud-input-root {
        border: none;
        box-shadow: none;
    }
    .position-select .mud-input-root:focus-within {
        box-shadow: none;
    }
    .route-error-panel {
        padding: 24px;
    }
    .notes-panel {
        height: 100%;
        padding: 16px;
        display: flex;
        flex-direction: column;
        gap: 12px;
    }
    .notes-panel .mud-input-root {
        flex: 1;
    }
    .position-summary-row {
        flex-wrap: wrap;
        gap: 6px;
    }
    .position-content {
        padding-top: 8px;
    }
    .chart-surface {
        padding: 16px;
    }
    .chart-controls-row {
        flex-wrap: wrap;
    }
    .payoff-chart-container {
        position: relative;
    }
    .payoff-chart-reset {
        position: absolute;
        right: 10px;
        bottom: 10px;
        z-index: 2;
    }
    @@media (max-width: 600px) {
        .chart-surface {
            padding: 8px 0;
        }
        .position-content {
            padding-left: 0;
            padding-right: 0;
        }
        .position-grid {
            margin-left: 0;
            margin-right: 0;
        }
        .position-grid > .mud-grid-item {
            padding-left: 0;
            padding-right: 0;
        }
    }
</style>

@code {
    private const string ChartRangeStoragePrefix = "positions.chartRange.";
    private int _activeTabIndex;
    private bool HasActivePosition => ViewModel.SelectedPosition?.Position is not null;
    private bool _viewModelReady;
    private Guid? _pendingRoutePositionId;
    private string? _routeErrorMessage;
    private IJSObjectReference? _chartRangeModule;
    private string? _restoredChartRangeKey;
    [Parameter] public Guid? PositionId { get; set; }

    protected override async Task OnInitializedAsync()
    {
        ViewModel.OnChange += HandleViewModelChanged;
        ViewModel.LivePriceChanged += HandleLivePriceChanged;
        await ViewModel.InitializeAsync(PositionId);
        _viewModelReady = true;
        await ApplyRouteAsync(_pendingRoutePositionId);
        await RestoreChartRangeIfMissingAsync();
    }

    public async ValueTask DisposeAsync()
    {
        ViewModel.OnChange -= HandleViewModelChanged;
        ViewModel.LivePriceChanged -= HandleLivePriceChanged;
        if (_chartRangeModule is not null)
        {
            await _chartRangeModule.DisposeAsync();
        }
        await ViewModel.DisposeAsync();
    }

    protected override async Task OnParametersSetAsync()
    {
        await base.OnParametersSetAsync();
        _pendingRoutePositionId = PositionId;
        if (_viewModelReady)
        {
            await ApplyRouteAsync(PositionId);
            await InvokeAsync(StateHasChanged);
        }
    }

    private Task HandleChartPriceSelected(double? price)
    {
        _ = InvokeAsync(async () =>
        {
            var start = System.Diagnostics.Stopwatch.StartNew();
            await Task.Yield();
            ViewModel.UpdateSelectedPrice(price.HasValue ? (decimal?)price.Value : null, refresh: false);
            StateHasChanged();
            start.Stop();
            Console.WriteLine($"[Positions.HandleChartPriceSelected] price={price} handlerMs={start.ElapsedMilliseconds} utc={DateTime.UtcNow:O}");
        });

        return Task.CompletedTask;
    }

    private Task HandleChartRangeChanged(ChartRange range)
    {
        ViewModel.UpdateChartRange(range);
        _ = SaveChartRangeAsync(range);
        return Task.CompletedTask;
    }

    private Task OnSwipeEnd(SwipeEventArgs args) => args.SwipeDirection switch
    {
        SwipeDirection.RightToLeft => ChangeTabByDelta(1),
        SwipeDirection.LeftToRight => ChangeTabByDelta(-1),
        _ => Task.CompletedTask
    };

    private async Task ChangeTabByDelta(int delta)
    {
        if (ViewModel.Positions.Count == 0)
        {
            return;
        }

        var nextIndex = Math.Clamp(_activeTabIndex + delta, 0, ViewModel.Positions.Count - 1);

        if (nextIndex != _activeTabIndex)
        {
            await OnTabChanged(nextIndex);
        }
    }

    private async Task HandlePositionChange(Guid? positionId)
    {
        if (!positionId.HasValue)
        {
            _routeErrorMessage = null;
            SyncActiveTabIndex();
            return;
        }

        var matched = ViewModel.Positions.FirstOrDefault(p => p.Id == positionId.Value);
        if (matched is null)
        {
            _routeErrorMessage = $"Position {positionId.Value} not found.";
            _activeTabIndex = -1;
            return;
        }

        var index = ViewModel.Positions.IndexOf(matched);
        await OnTabChanged(index);
    }

    private async Task OnTemporaryPriceChanged(decimal? price)
    {
        ViewModel.UpdateSelectedPrice(price, refresh: false);
        await InvokeAsync(StateHasChanged);
    }

    private async Task OnLivePriceChanged(bool isEnabled)
    {
        await ViewModel.SetIsLiveAsync(isEnabled);
        await InvokeAsync(StateHasChanged);
    }

    private void HandleViewModelChanged()
    {
        _ = InvokeAsync(StateHasChanged);
    }

    private void HandleLivePriceChanged(decimal? price)
    {
        _ = InvokeAsync(() =>
        {
            ViewModel.UpdateChartSelectedPrice(price);
            StateHasChanged();
        });
    }

    private Task OnValuationDateChanged(DateTime? date)
    {
        if (date.HasValue)
        {
            ViewModel.SetValuationDate(date.Value);
        }
        else
        {
            ViewModel.ResetValuationDateToToday();
        }

        return InvokeAsync(StateHasChanged);
    }

    private Task OnValuationDateOffsetChanged(int offset)
    {
        ViewModel.SetValuationDateFromOffset(offset);
        return InvokeAsync(StateHasChanged);
    }



    private async Task CreatePosition()
    {
        var initialName = $"Position {ViewModel.Positions.Count + 1}";
        var initialBaseAsset = ViewModel.SelectedPosition?.Position?.BaseAsset ?? "ETH";
        var initialQuoteAsset = ViewModel.SelectedPosition?.Position?.QuoteAsset ?? "USDT";

        var dialogViewModel = await NavigationService.NavigateToAsync<PositionCreateDialogViewModel>(viewModel =>
            viewModel.InitializeAsync(initialName, initialBaseAsset, initialQuoteAsset));

        var request = await dialogViewModel.WaitForResultAsync();
        if (request is null)
        {
            return;
        }

        var includeSampleLegs = request.SelectedBybitPositions.Count == 0 && request.InitialLegs.Count == 0;
        await ViewModel.AddPositionAsync(request.Name, request.BaseAsset, request.QuoteAsset, includeSampleLegs, request.InitialLegs);
        if (request.SelectedBybitPositions.Count > 0 && ViewModel.SelectedPosition is not null)
        {
            var collection = ViewModel.SelectedPosition.Collections.FirstOrDefault();
            if (collection is not null)
            {
                await collection.AddBybitPositionsToCollectionAsync(request.SelectedBybitPositions);
            }
        }
        _activeTabIndex = Math.Max(0, ViewModel.Positions.Count - 1);
        await RefreshChartAsync();
        if (ViewModel.SelectedPosition?.Position?.Id is Guid newId && newId != Guid.Empty)
        {
            UpdateUrl(newId);
        }
    }

    private void SyncActiveTabIndex()
    {
        var selectedIndex = ViewModel.SelectedPosition?.Position is null ? -1 : ViewModel.Positions.IndexOf(ViewModel.SelectedPosition.Position);

        if (selectedIndex >= 0)
        {
            _activeTabIndex = selectedIndex;
        }
        else if (ViewModel.Positions.Count > 0)
        {
            _activeTabIndex = 0;
        }
    }

    private async Task OnTabChanged(int index)
    {
        if (index < 0 || index >= ViewModel.Positions.Count)
        {
            SyncActiveTabIndex();
            return;
        }

        var positionId = ViewModel.Positions[index].Id;

        if (await ViewModel.SelectPositionAsync(positionId))
        {
            _activeTabIndex = index;
            await RefreshChartAsync();
            await RestoreChartRangeIfMissingAsync();
            _routeErrorMessage = null;
            UpdateUrl(positionId);
            return;
        }

        _routeErrorMessage = $"Position {positionId} no longer exists.";
        _activeTabIndex = -1;
    }

    private async Task OpenRenameDialogAsync()
    {
        if (ViewModel.SelectedPosition?.Position is null)
        {
            return;
        }

        var parameters = new DialogParameters
        {
            [nameof(PositionNameDialog.InitialName)] = ViewModel.SelectedPosition?.Position?.Name
        };

        var options = new DialogOptions
        {
            CloseOnEscapeKey = true,
            MaxWidth = MaxWidth.Small,
            FullWidth = true
        };

        var dialog = await DialogService.ShowAsync<PositionNameDialog>("Edit position", parameters, options);
        var result = await dialog.Result;

        if (result is null || result.Canceled || result.Data is not string name)
        {
            return;
        }

        var active = ViewModel.SelectedPosition?.Position;

        if (active is null)
        {
            return;
        }

        await ViewModel.UpdateNameAsync(active, name);
        StateHasChanged();
    }


    private async Task ConfirmAndRemovePositionAsync(PositionViewModel? position)
    {
        if (position?.Position is null)
        {
            return;
        }


        var confirmed = await DialogService.ShowMessageBox("Remove position?", $"Delete {position.Position.Name} and its chart view?", yesText: "Delete", cancelText: "Cancel");

        if (confirmed != true)
        {
            return;
        }

        if (await ViewModel.RemovePositionAsync(position.Position))
        {
            SyncActiveTabIndex();
            await RefreshChartAsync();
        }
    }

    private Task RefreshChartAsync()
    {
        ViewModel.UpdateChart();
        return InvokeAsync(StateHasChanged);
    }

    private async Task RestoreChartRangeIfMissingAsync()
    {
        if (ViewModel.ChartRange is not null)
        {
            return;
        }

        var storageKey = GetChartRangeStorageKey();
        if (string.IsNullOrWhiteSpace(storageKey))
        {
            return;
        }

        if (string.Equals(_restoredChartRangeKey, storageKey, StringComparison.Ordinal))
        {
            return;
        }

        var module = await GetChartRangeModuleAsync();
        if (module is null)
        {
            return;
        }

        ChartRange? stored = null;
        try
        {
            stored = await module.InvokeAsync<ChartRange?>("getRange", storageKey);
        }
        catch (JSException)
        {
            return;
        }

        _restoredChartRangeKey = storageKey;
        if (stored is null)
        {
            return;
        }

        ViewModel.UpdateChartRange(stored);
        await InvokeAsync(StateHasChanged);
    }

    private async Task SaveChartRangeAsync(ChartRange range)
    {
        var storageKey = GetChartRangeStorageKey();
        if (string.IsNullOrWhiteSpace(storageKey))
        {
            return;
        }

        var module = await GetChartRangeModuleAsync();
        if (module is null)
        {
            return;
        }

        try
        {
            await module.InvokeVoidAsync("setRange", storageKey, range);
        }
        catch (JSException)
        {
            // ignore storage failures
        }
    }

    private string? GetChartRangeStorageKey()
    {
        var id = ViewModel.SelectedPosition?.Position?.Id;
        if (!id.HasValue || id.Value == Guid.Empty)
        {
            return null;
        }

        return $"{ChartRangeStoragePrefix}{id.Value}";
    }

    private async Task<IJSObjectReference?> GetChartRangeModuleAsync()
    {
        if (_chartRangeModule is not null)
        {
            return _chartRangeModule;
        }

        try
        {
            _chartRangeModule = await JS.InvokeAsync<IJSObjectReference>("import", "./js/chartRangeStorage.js");
        }
        catch (JSException)
        {
            _chartRangeModule = null;
        }

        return _chartRangeModule;
    }

    private async Task ApplyRouteAsync(Guid? routePositionId)
    {
        _routeErrorMessage = null;

        if (!routePositionId.HasValue)
        {
            SyncActiveTabIndex();
            return;
        }

        if (ViewModel.SelectedPosition?.Position?.Id == routePositionId.Value)
        {
            SyncActiveTabIndex();
            return;
        }

        if (!await ViewModel.SelectPositionAsync(routePositionId.Value))
        {
            _routeErrorMessage = $"Position {routePositionId.Value} not found.";
            _activeTabIndex = -1;
            return;
        }

        SyncActiveTabIndex();
        await RefreshChartAsync();
        await RestoreChartRangeIfMissingAsync();
        UpdateUrl(routePositionId.Value);
    }

    private void UpdateUrl(Guid positionId)
    {
        var targetUri = $"/positions/{positionId}";
        var absoluteTarget = NavigationManager.ToAbsoluteUri(targetUri).ToString();

        if (!string.Equals(NavigationManager.Uri, absoluteTarget, StringComparison.OrdinalIgnoreCase))
        {
            NavigationManager.NavigateTo(targetUri);
        }
    }

    private void NavigateToFirstPosition()
    {
        if (ViewModel.Positions.Count == 0)
        {
            NavigationManager.NavigateTo("/positions");
            return;
        }

        UpdateUrl(ViewModel.Positions[0].Id);
    }

    private static string ResolveAssetLabel(string? value)
    {
        return string.IsNullOrWhiteSpace(value) ? "N/A" : value.Trim().ToUpperInvariant();
    }

    private static string FormatPositionName(PositionModel position)
    {
        var baseAsset = ResolveAssetLabel(position.BaseAsset);
        var quoteAsset = ResolveAssetLabel(position.QuoteAsset);
        var name = string.IsNullOrWhiteSpace(position.Name) ? "Position" : position.Name.Trim();
        return $"{baseAsset}/{quoteAsset} - {name}";
    }

    private decimal? ResolveTotalTempPnl()
    {
        var selected = ViewModel.SelectedPosition;
        if (selected is null)
        {
            return null;
        }

        decimal total = 0;
        var hasValue = false;
        foreach (var collection in selected.Collections)
        {
            if (!collection.Collection.IsVisible)
            {
                continue;
            }

            var value = collection.TotalTempPnl;
            if (!value.HasValue)
            {
                continue;
            }

            total += value.Value;
            hasValue = true;
        }

        return hasValue ? total : null;
    }

    private static string FormatPrice(decimal? price)
    {
        return price.HasValue ? price.Value.ToString("0.00") : "-";
    }

    private static Color ResolvePnlColor(decimal? value)
    {
        if (!value.HasValue)
        {
            return Color.Default;
        }

        return value.Value >= 0 ? Color.Success : Color.Error;
    }

    private decimal? ResolveClosedNetPnl()
    {
        var closed = ViewModel.SelectedPosition?.Position?.Closed;
        if (closed is null)
        {
            return null;
        }

        return closed.TotalNet;
    }

    private decimal? ResolveTotalCombinedPnl()
    {
        var temp = ResolveTotalTempPnl();
        var closed = ResolveClosedNetPnl();

        if (!temp.HasValue && !closed.HasValue)
        {
            return null;
        }

        return (temp ?? 0m) + (closed ?? 0m);
    }

}
