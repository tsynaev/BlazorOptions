@page "/position/{PositionId:guid}"

@implements IAsyncDisposable
@inject PositionViewModel ViewModel
@inject IDialogService DialogService
@inject NavigationManager NavigationManager
@inject IJSRuntime JS
@using System.Collections.ObjectModel
@using Microsoft.JSInterop
@using BlazorOptions.Shared
@using BlazorOptions.ViewModels
@using BlazorChart.Models

<PageTitle>Position</PageTitle>

@if (ViewModel.ErrorMessage is not null)
{
    <MudStack Spacing="2" Class="route-error-panel">
        <MudAlert Severity="Severity.Error" Variant="Variant.Filled">
            @ViewModel.ErrorMessage
        </MudAlert>
        <MudStack Row="true" Spacing="1">
            <MudButton Color="Color.Primary" Variant="Variant.Filled" Href="/">Open dashboard</MudButton>
        </MudStack>
    </MudStack>
}
else if (_isRouteLoading)
{
    <MudStack Class="pa-6" AlignItems="AlignItems.Center" Justify="Justify.Center">
        <MudProgressCircular Indeterminate="true" Color="Color.Primary" Size="Size.Large" />
    </MudStack>
}
else
{
    <MudStack>
        <MudCard>
        <MudCardContent>
            <MudStack Spacing="2">
                <MudStack Spacing="1">
                    <MudStack Row="true" AlignItems="AlignItems.Center" Justify="Justify.SpaceBetween" Spacing="2">
                        <MudText Typo="Typo.h6">
                            @(!HasActivePosition
                                ? "No position selected"
                                : FormatPositionName(ViewModel.Position))
                        </MudText>
                        <MudMenu Icon="@Icons.Material.Filled.MoreVert"
                                 Disabled="@(!HasActivePosition)"
                                 Dense="true"
                                 AnchorOrigin="Origin.BottomCenter"
                                 TransformOrigin="Origin.TopCenter"
                                 ListClass="tab-actions-menu">
                            <MudMenuItem Disabled="@(!HasActivePosition)" OnClick="OpenRenameDialogAsync">
                                <MudIcon Icon="@Icons.Material.Filled.Edit" Class="mr-2" /> Edit position
                            </MudMenuItem>
                            <MudMenuItem Disabled="@(!HasActivePosition)" OnClick="ConfirmAndRemovePositionAsync">
                                <MudIcon Icon="@Icons.Material.Filled.Delete" Class="mr-2" /> Delete position
                            </MudMenuItem>
                        </MudMenu>
                    </MudStack>
                </MudStack>
            </MudStack>
        </MudCardContent>
        <MudCardContent Class="position-content">
            <MudGrid Spacing="2" Class="position-grid">
                <MudItem xs="12" md="8">
                    <MudPaper Class="chart-surface" Elevation="0">
                        <MudStack Spacing="2">
                            <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="1" Class="position-summary-row">
                                <MudChip T="string" Variant="Variant.Filled" Size="Size.Small" Color="@ResolvePnlColor(ResolveTotalCombinedPnl())">
                                    Total P/L: @FormatPrice(ResolveTotalCombinedPnl())
                                </MudChip>
                                <MudChip T="string"
                                         Variant="Variant.Outlined"
                                         Size="Size.Small"
                                         Color="@(ViewModel.IsLive ? Color.Success : Color.Default)"
                                         OnClick="ToggleLive">
                                    Live: @(ViewModel.IsLive ? "On" : "Off")
                                </MudChip>
                                <MudChip T="string"
                                         Variant="Variant.Outlined"
                                         Size="Size.Small"
                                         Color="@(ViewModel.ShowCandles ? Color.Info : Color.Default)"
                                         OnClick="ToggleCandles">
                                    Candles: @(ViewModel.ShowCandles ? "On" : "Off")
                                </MudChip>
                            </MudStack>
                           
                            <PayoffChart Strategies="@DisplayChartStrategies"
                                         SelectedPrice="@DisplaySelectedPrice"
                                         SelectedPriceChanged="HandleChartPriceSelected"
                                         Markers="@DisplayChartMarkers"
                                         Candles="@DisplayChartCandles"
                                         ShowCandles="@DisplayShowCandles"
                                         ShowLegends="true"
                                         IsDarkTheme="@IsDarkMode"
                                         Range="@ViewModel.ChartRange"
                                         RangeChanged="HandleChartRangeChanged"
                                         TimeRange="@ViewModel.ChartTimeRange"
                                         TimeRangeChanged="HandleChartTimeRangeChanged" />

                                <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2" Class="chart-controls-row">
                                    <MudText Typo="Typo.subtitle2">Valuation date</MudText>
                                    <MudDatePicker Date="@ViewModel.ValuationDate"
                                                   DateChanged="OnValuationDateChanged"
                                                   DateFormat="yyyy-MM-dd"
                                                   Clearable="true"
                                                   MinDate="@DateTime.UtcNow.Date"
                                                   MaxDate="@ViewModel.MaxExpiryDate"
                                                   Class="valuation-date-picker" />
                                    <MudText Typo="Typo.caption">@ViewModel.DaysToExpiryLabel</MudText>
                                    <MudSpacer />
                                    <MudText Typo="Typo.caption" Class="ml-2">Index Price</MudText>
                                    <MudNumericField T="decimal?"
                                                     Value="@ViewModel.SelectedPrice"
                                                     ValueChanged="OnTemporaryPriceChanged"
                                                     Immediate="true"
                                                     Variant="Variant.Outlined"
                                                     Margin="Margin.Dense"
                                                     Adornment="Adornment.End"
                                                     AdornmentText="USDT"
                                                     Class="temp-price-field" />
                                </MudStack>
                                <MudSlider T="int"
                                           Min="0"
                                           Max="@ViewModel.MaxExpiryDays"
                                           Step="1"
                                           Value="@ViewModel.SelectedDayOffset"
                                           ValueChanged="OnValuationDateOffsetChanged"
                                           TickMarks="true"
                                           Class="valuation-date-slider" />
                        </MudStack>
                    </MudPaper>
                </MudItem>
                @if (HasActivePosition)
                {
                    <MudItem xs="12" md="4">
                        <MudPaper Class="notes-panel" Elevation="0">
                            <MudText Typo="Typo.subtitle2">Notes</MudText>
                            <MudTextField T="string"
                                          @bind-Value="@ViewModel.Position.Notes"

                                          Variant="Variant.Outlined"
                                          Margin="Margin.Dense"
                                          Lines="16"
                                          FullWidth="true"
                                          Placeholder="Write notes about this position..."/>
                        </MudPaper>
                    </MudItem>
                }
            </MudGrid>
        </MudCardContent>
    </MudCard>

        @if (HasActivePosition)
        {
            <PositionPanel ViewModel="@ViewModel" />
        }

    </MudStack>
}

<style>
    .position-swipe-area {
        display: block;
        flex: 1;
        min-width: 0;
    }

    .position-tabs .mud-tabs-toolbar {
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
    }

    .position-tabs .mud-tabs-toolbar-content {
        flex-wrap: nowrap;
    }

    .position-tabs .d-none {
        display: none !important;
    }

    .tab-name-field {
        min-width: 140px;
    }

    .tab-name-label {
        display: inline-block;
        max-width: 180px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        padding: 6px 12px;
    }

    .tab-actions-menu {
        min-width: 180px;
    }

    .temp-price-field {
        max-width: 180px;
    }

    .valuation-date-slider {
        padding: 0 14px 16px;
    }

    .valuation-date-picker {
        min-width: 140px;
        max-width: 170px;
        width: 170px;
    }

    .quick-leg-input {
        width: 220px;
    }
    .position-select-row {
        flex-wrap: wrap;
        gap: 8px;
        width: 100%;
    }
    .position-select-row .mud-select-root {
        flex: 1;
        min-width: 0;
    }
    .position-select .mud-input-root {
        border: none;
        box-shadow: none;
    }
    .position-select .mud-input-root:focus-within {
        box-shadow: none;
    }
    .route-error-panel {
        padding: 24px;
    }
    .notes-panel {
        height: 100%;
        padding: 16px;
        display: flex;
        flex-direction: column;
        gap: 12px;
    }
    .notes-panel .mud-input-root {
        flex: 1;
    }
    .position-summary-row {
        flex-wrap: wrap;
        gap: 6px;
    }
    .position-content {
        padding-top: 8px;
    }
    .chart-surface {
        padding: 16px;
    }
    .chart-controls-row {
        flex-wrap: wrap;
    }
    .payoff-chart-reset {
        position: absolute;
        right: 10px;
        bottom: 10px;
        z-index: 2;
    }
    @@media (max-width: 600px) {
        .chart-surface {
            padding: 8px 0;
        }
        .position-content {
            padding-left: 0;
            padding-right: 0;
        }
        .position-grid {
            margin-left: 0;
            margin-right: 0;
        }
        .position-grid > .mud-grid-item {
            padding-left: 0;
            padding-right: 0;
        }
    }
</style>

@code {
    private static readonly ObservableCollection<StrategySeries> EmptyStrategies = new();
    private static readonly ObservableCollection<PriceMarker> EmptyMarkers = new();
    private static readonly ObservableCollection<CandlePoint> EmptyCandles = new();

    private const string ChartRangeStoragePrefix = "positions.chartRange.";
    private const string ChartTimeIntervalStorageKey = "positions.chartTimeIntervalMs";
    private bool HasActivePosition => _viewModelReady && ViewModel.Position?.Id != Guid.Empty;
    private bool _viewModelReady;
    private bool _isRouteLoading = true;
    private Guid? _pendingRoutePositionId;
    private IJSObjectReference? _chartRangeModule;
    private string? _restoredChartRangeKey;
    private readonly object _liveRenderLock = new();
    private CancellationTokenSource? _liveRenderCts;
    private static readonly TimeSpan LiveRenderDebounce = TimeSpan.FromMilliseconds(120);



    [CascadingParameter] public bool IsDarkMode { get; set; }
    [Parameter] public Guid? PositionId { get; set; }

    protected override async Task OnInitializedAsync()
    {
        _isRouteLoading = true;
        try
        {
            ViewModel.ErrorMessage = null;

            if (!PositionId.HasValue || PositionId.Value == Guid.Empty)
            {
                ViewModel.ErrorMessage = "Open a position from the dashboard.";
                return;
            }


            ViewModel.OnChange += HandleViewModelChanged;
            ViewModel.LivePriceChanged += HandleLivePriceChanged;

            _isRouteLoading = true;
            await InvokeAsync(StateHasChanged);

            await ViewModel.InitializeAsync(PositionId.Value);
            _viewModelReady = true;


            await InvokeAsync(StateHasChanged);

            await RestoreChartRangeIfMissingAsync();
            await RestoreChartTimeIntervalAsync();

        }
        finally
        {
            _isRouteLoading = false;
        }
    }

    public async ValueTask DisposeAsync()
    {
        ViewModel.OnChange -= HandleViewModelChanged;
        ViewModel.LivePriceChanged -= HandleLivePriceChanged;
        if (_chartRangeModule is not null)
        {
            await _chartRangeModule.DisposeAsync();
        }
        CancelLiveRenderDebounce();
        await ViewModel.DisposeAsync();
    }

    // protected override async Task OnParametersSetAsync()
    // {
    //     await base.OnParametersSetAsync();
    //     _isRouteLoading = true;
    //     _pendingRoutePositionId = PositionId;
    //     if (!_viewModelReady && PositionId.HasValue && PositionId.Value != Guid.Empty)
    //     {
    //         await ViewModel.InitializeAsync(PositionId);
    //         _viewModelReady = true;
    //     }

    //     if (_viewModelReady)
    //     {
    //         await ApplyRouteAsync(PositionId);
    //         await InvokeAsync(StateHasChanged);
    //     }
    //     else
    //     {
    //         ViewModel.ErrorMessage = "Open a position from the dashboard.";
    //         _isRouteLoading = false;
    //     }
    // }

    private Task HandleChartPriceSelected(double? price)
    {
        _ = InvokeAsync(async () =>
        {
            ViewModel.UpdateSelectedPrice(price.HasValue ? (decimal?)price.Value : null, refresh: false);
            StateHasChanged();
        });

        return Task.CompletedTask;
    }

    private Task HandleChartRangeChanged(ChartRange range)
    {
        ViewModel.UpdateChartRange(range);
        _ = SaveChartRangeAsync(range);
        return Task.CompletedTask;
    }

    private async Task OnTemporaryPriceChanged(decimal? price)
    {
        ViewModel.UpdateSelectedPrice(price, refresh: false);
        await InvokeAsync(StateHasChanged);
    }

    private void HandleViewModelChanged()
    {
        _ = InvokeAsync(StateHasChanged);
    }

    private void HandleLivePriceChanged(decimal? price)
    {
        _ = DebounceLiveRenderAsync();
    }

    private Task OnValuationDateChanged(DateTime? date)
    {
        if (date.HasValue)
        {
            ViewModel.SetValuationDate(date.Value);
        }
        else
        {
            ViewModel.ResetValuationDateToToday();
        }

        return InvokeAsync(StateHasChanged);
    }

    private Task OnValuationDateOffsetChanged(int offset)
    {
        ViewModel.SetValuationDateFromOffset(offset);
        return InvokeAsync(StateHasChanged);
    }

    private async Task ToggleCandles()
    {
        await ViewModel.SetShowCandlesAsync(!ViewModel.ShowCandles);
        if (ViewModel.ChartTimeRange is not null)
        {
            await SaveChartTimeIntervalAsync(ViewModel.ChartTimeRange);
        }
        await InvokeAsync(StateHasChanged);
    }

    private async Task ToggleLive()
    {
        await ViewModel.SetIsLiveAsync(!ViewModel.IsLive);
        await InvokeAsync(StateHasChanged);
    }

    private async Task HandleChartTimeRangeChanged(TimeRange range)
    {
        await ViewModel.UpdateChartTimeRangeAsync(range);
        await SaveChartTimeIntervalAsync(range);
        await InvokeAsync(StateHasChanged);
    }
    private async Task OpenRenameDialogAsync()
    {
        if (!HasActivePosition)
        {
            return;
        }

        var parameters = new DialogParameters
        {
            [nameof(PositionNameDialog.InitialName)] = ViewModel.Position.Name
        };

        var options = new DialogOptions
        {
            CloseOnEscapeKey = true,
            MaxWidth = MaxWidth.Small,
            FullWidth = true
        };

        var dialog = await DialogService.ShowAsync<PositionNameDialog>("Edit position", parameters, options);
        var result = await dialog.Result;

        if (result is null || result.Canceled || result.Data is not string name)
        {
            return;
        }

        await ViewModel.UpdateNameAsync(ViewModel.Position, name);
        StateHasChanged();
    }


    private async Task ConfirmAndRemovePositionAsync()
    {
        if (!HasActivePosition)
        {
            return;
        }


        var positionName = string.IsNullOrWhiteSpace(ViewModel.Position.Name)
            ? "this position"
            : ViewModel.Position.Name;
        var confirmed = await DialogService.ShowMessageBox(
            "Remove position?",
            $"Delete {positionName} and its chart view?",
            yesText: "Delete",
            cancelText: "Cancel");

        if (confirmed != true)
        {
            return;
        }

        if (await ViewModel.RemovePositionAsync(ViewModel.Position))
        {
            NavigationManager.NavigateTo("/");
        }
    }

    private async Task RestoreChartRangeIfMissingAsync()
    {
        if (ViewModel.ChartRange is not null)
        {
            return;
        }

        var storageKey = GetChartRangeStorageKey();
        if (string.IsNullOrWhiteSpace(storageKey))
        {
            return;
        }

        if (string.Equals(_restoredChartRangeKey, storageKey, StringComparison.Ordinal))
        {
            return;
        }

        var module = await GetChartRangeModuleAsync();
        if (module is null)
        {
            return;
        }

        ChartRange? stored = null;
        try
        {
            stored = await module.InvokeAsync<ChartRange?>("getRange", storageKey);
        }
        catch (JSException)
        {
            return;
        }

        _restoredChartRangeKey = storageKey;
        if (stored is null)
        {
            return;
        }

        ViewModel.UpdateChartRange(stored);
        await InvokeAsync(StateHasChanged);
    }

    private async Task SaveChartRangeAsync(ChartRange range)
    {
        var storageKey = GetChartRangeStorageKey();
        if (string.IsNullOrWhiteSpace(storageKey))
        {
            return;
        }

        var module = await GetChartRangeModuleAsync();
        if (module is null)
        {
            return;
        }

        try
        {
            await module.InvokeVoidAsync("setRange", storageKey, range);
        }
        catch (JSException)
        {
            // ignore storage failures
        }
    }

    private async Task RestoreChartTimeIntervalAsync()
    {
        if (ViewModel.ChartTimeRange is not null)
        {
            return;
        }

        var module = await GetChartRangeModuleAsync();
        if (module is null)
        {
            return;
        }

        double? intervalMs = null;
        try
        {
            intervalMs = await module.InvokeAsync<double?>("getTimeIntervalMs", ChartTimeIntervalStorageKey);
        }
        catch (JSException)
        {
            return;
        }

        if (!intervalMs.HasValue || intervalMs.Value <= 0)
        {
            return;
        }

        var nowMs = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();
        var fromMs = nowMs - intervalMs.Value;
        if (fromMs >= nowMs)
        {
            return;
        }

        await ViewModel.UpdateChartTimeRangeAsync(new TimeRange(fromMs, nowMs));
        await InvokeAsync(StateHasChanged);
    }

    private async Task SaveChartTimeIntervalAsync(TimeRange range)
    {
        var intervalMs = range.Max - range.Min;
        if (intervalMs <= 0)
        {
            return;
        }

        var module = await GetChartRangeModuleAsync();
        if (module is null)
        {
            return;
        }

        try
        {
            await module.InvokeVoidAsync("setTimeIntervalMs", ChartTimeIntervalStorageKey, intervalMs);
        }
        catch (JSException)
        {
            // ignore storage failures
        }
    }

    private string? GetChartRangeStorageKey()
    {
        if (!HasActivePosition)
        {
            return null;
        }

        return $"{ChartRangeStoragePrefix}{ViewModel.Position.Id}";
    }

    private async Task<IJSObjectReference?> GetChartRangeModuleAsync()
    {
        if (_chartRangeModule is not null)
        {
            return _chartRangeModule;
        }

        try
        {
            _chartRangeModule = await JS.InvokeAsync<IJSObjectReference>("import", "./js/chartRangeStorage.js");
        }
        catch (JSException)
        {
            _chartRangeModule = null;
        }

        return _chartRangeModule;
    }

  

    private ObservableCollection<StrategySeries> DisplayChartStrategies =>
        _isRouteLoading ? EmptyStrategies : ViewModel.ChartStrategies;

    private ObservableCollection<PriceMarker> DisplayChartMarkers =>
        _isRouteLoading ? EmptyMarkers : ViewModel.ChartMarkers;

    private ObservableCollection<CandlePoint> DisplayChartCandles =>
        _isRouteLoading ? EmptyCandles : ViewModel.ChartCandles;

    private double? DisplaySelectedPrice => _isRouteLoading ? null : ViewModel.ChartSelectedPrice;

    private bool DisplayShowCandles => !_isRouteLoading && ViewModel.ShowCandles;

    private async Task DebounceLiveRenderAsync()
    {
        CancellationToken token;
        lock (_liveRenderLock)
        {
            _liveRenderCts?.Cancel();
            _liveRenderCts?.Dispose();
            _liveRenderCts = new CancellationTokenSource();
            token = _liveRenderCts.Token;
        }

        try
        {
            await Task.Delay(LiveRenderDebounce, token);
        }
        catch (TaskCanceledException)
        {
            return;
        }

        if (token.IsCancellationRequested)
        {
            return;
        }

        await InvokeAsync(StateHasChanged);
    }

    private void CancelLiveRenderDebounce()
    {
        lock (_liveRenderLock)
        {
            if (_liveRenderCts is null)
            {
                return;
            }

            _liveRenderCts.Cancel();
            _liveRenderCts.Dispose();
            _liveRenderCts = null;
        }
    }

    private static string ResolveAssetLabel(string? value)
    {
        return string.IsNullOrWhiteSpace(value) ? "N/A" : value.Trim().ToUpperInvariant();
    }

    private static string FormatPositionName(PositionModel position)
    {
        var baseAsset = ResolveAssetLabel(position.BaseAsset);
        var quoteAsset = ResolveAssetLabel(position.QuoteAsset);
        var name = string.IsNullOrWhiteSpace(position.Name) ? "Position" : position.Name.Trim();
        return $"{baseAsset}/{quoteAsset} - {name}";
    }

    private decimal? ResolveTotalTempPnl()
    {
        if (!HasActivePosition)
        {
            return null;
        }

        decimal total = 0;
        var hasValue = false;
        foreach (var collection in ViewModel.Collections)
        {
            if (!collection.Collection.IsVisible)
            {
                continue;
            }

            var value = collection.TotalTempPnl;
            if (!value.HasValue)
            {
                continue;
            }

            total += value.Value;
            hasValue = true;
        }

        return hasValue ? total : null;
    }

    private static string FormatPrice(decimal? price)
    {
        return price.HasValue ? price.Value.ToString("0.00") : "-";
    }

    private static Color ResolvePnlColor(decimal? value)
    {
        if (!value.HasValue)
        {
            return Color.Default;
        }

        return value.Value >= 0 ? Color.Success : Color.Error;
    }

    private decimal? ResolveClosedNetPnl()
    {
        var closed = HasActivePosition ? ViewModel.Position.Closed : null;
        if (closed is null)
        {
            return null;
        }

        return closed.TotalNet;
    }

    private decimal? ResolveTotalCombinedPnl()
    {
        var temp = ResolveTotalTempPnl();
        var closed = ResolveClosedNetPnl();

        if (!temp.HasValue && !closed.HasValue)
        {
            return null;
        }

        return (temp ?? 0m) + (closed ?? 0m);
    }

}
